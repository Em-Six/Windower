_addon.name = 'Silmaril'
_addon.author = 'Mirdain'
_addon.version = '2.2'
_addon_description = 'Allows for buffs, debuffs, ranged attacks, skill chains, magic bursts, and casting data'
_addon.commands = {'silmaril','sm'}

os.setlocale ("en")

packets = require 'packets'
config = require 'config'
res = require 'resources'
texts = require 'texts'

require 'tables'
require 'strings'

-- These are Windower Raw values and refreshed via the "Update" function
player = {} -- get_player() 
pet = {}
party = {} -- get_party()
inventory = {} -- get_bag_info(0)
mob_array = {} -- grabs enemies via get_mob_array() under the tracking.lua
world = {} -- get_info()
ability_recasts = {} -- get_ability_recasts()
spell_recasts = {} -- get_spell_recasts()
spells_have = {} -- get_spells() via Update.lua

all_ability_recasts = res.ability_recasts -- Table with all abilities (loaded from windower resource files)
all_buffs = res.buffs -- Remaps so that geomancy buffs are fixed
all_job_abilities = res.job_abilities -- Store the resource information in a table
all_weapon_skills = res.weapon_skills -- Store the resource information in a table
all_spells = res.spells -- Store the resource information in a table
all_items = res.items -- Store the resource information in a table

--Update.lua
party_data = {} -- holds party information (generated by Party.lua)
party_buffs = {} -- holds buff list (generated by Player.lua and by Buffs.lua via packets)
player_status = {} -- hold character information (generated by Player.lua)
player_job_abilities_recasts = {} -- holds the characters recast timers of JA's (generated by Abilities.lua)
player_spell_recasts = {} -- holds the characters recast timers of spells (generated by Spells.lua)
player_world_data = {} -- holds the information on the world data
player_enemy_data = {} -- holds the information on the enemies data via World.lua
player_npc_data = {} -- holds the information on the enemies data via World.lua
player_task_data = {} -- holds the tasks to send to Silmaril
player_attack_target = "" -- holds the enemy that is currently being attacked
player_item_data = nil -- holds the inventory items to send to silmaril

--Others
player_zone_data = {} -- holds the information on the zone data
player_city_data = {} -- holds the information on the city data
player_location = {} -- stores the location of player via Moving_Check() in Moving.lua
party_location = {} -- stores the location of the party via Moving_Check() in Moving.lua
player_abilities = {} -- used via "job_sync" in "Sync.lua"

-- Global variables
enabled = false
connected = false
loaded = false
autoload = true
moving = false
following = false
delay_time = 0 -- Assign a random number to stagger the instances

update_rate = .2 -- rate at which the updates are sent to Silmaril
last_update = os.clock()

update_movement = .1 -- rate at which movement checks are done (limit to 30 fps)
last_movement = os.clock()

update_inventory = 2 -- rate at which the game checks the players inventory
last_inventory = os.clock()

-- socket
socket = require("socket")
udp = nil
port = 2025
ip = "127.0.0.1"

require 'lib./Abilities' --Gets information about the player abilities
require 'lib./Actions' --Handles aciton messages
require 'lib./Buffs' --Used to process incoming buff packets for other party members
require 'lib./Burst' --Selects and returns the spell to burst
require 'lib./Commands' --Handles addon commands
require 'lib./Connection' --Send and Receive information
require 'lib./Display' --Send and Receive information
require 'lib./Input' --Receive commands to execute
require 'lib./Inventory' --Build the inventory information
require 'lib./Maps' --Allows for Geomancy and any future Buff updates by remapping to Silmaril
require 'lib./Moving' --Controls moving of charater
require 'lib./Party' --Gets information about the current party and alliance
require 'lib./Player' --Gets information about the player
require 'lib./Skillchain' --Monitors action packets to build skillchains with
require 'lib./Spells' --Gets information about the player spells
require 'lib./Sync' --Gets information about ffxi and sends to the Silmaril
require 'lib./Tracking' --Used to handle targets and identify wanted enemies
require 'lib./Update' --Sets pace and updates globals form windower
require 'lib./World' --Gets information about the world

--Commands recieved and sent to addon
windower.register_event('addon command', function(input, ...)
    local args = L{...}
    log(args)
    commands(input,args)
end)

--Used to collect buffs of other instances on the same pc
windower.register_event('ipc message', function(msg)
    local args = msg:split(' ')
    local command = args:remove(1)
    if command == 'update' then
        local character = { id = tonumber(args[1]), name = args[2], zone = tonumber(args[3]), x = tonumber(args[4]), y = tonumber(args[5]), z = tonumber(args[6])}
        party_location[tonumber(args[1])] = character
    elseif command == 'zone' then
        log('recieved IPC message of zone')
        zone_check(tonumber(args[1]),tonumber(args[2]),tonumber(args[3]))
    elseif command and args[2] then
        log("IPC: ["..command.."] ["..args[2].."]")
        commands(command, args[2])
    elseif command then
        log("IPC: ["..command.."]")
        commands(command, "")
    end
end)

-- Used to track incoming information
windower.register_event('incoming chunk', function (id, original, modified, injected, blocked)
    message_in(id, original) -- process the packets via Actions.lua
end)

-- Used to track outgoing information
windower.register_event('outgoing chunk', function (id, original)
    message_out(id, original) -- process the packets via Actions.lua
end)

windower.register_event('load', function()
    randomseed()
    delay_time = math.random(100,200)/100
    connect()
end)

windower.register_event('logout', function()
    send_packet(player.name..";reset")
    disconnect()
    log("logging out")
end)

windower.register_event('job change', function()
    coroutine.sleep(5)
    player = windower.ffxi.get_player()
    get_player_spells()
    autoload = true
end)

windower.register_event('zone change', function()
    player = windower.ffxi.get_player()
    world = windower.ffxi.get_info()
    if player then
        commands("stop", "")
    end
end)

windower.register_event('unload', function()
    send_packet(player.name..";reset")
    disconnect()
    log("unloaded")
end)

windower.register_event('prerender', function()
    if loaded then
        receive_info()
        local now = os.clock() -- used to determine the elapsed time
        if now - last_movement > update_movement then
            moving_check() -- Update the player location and do any movements via Moving.lua.  This allows accurate movements
            last_movement = now
        end
        if now - last_inventory > update_inventory then
            get_inventory()
            last_inventory = now
        end
        if now - last_update > update_rate then
            if not connected then
                request()
                following = false
                enabled = false
            else
                update() -- Via Update.lua
                if autoload then
                    autoload = false;
                    send_packet(player.name..";load_"..res.jobs[player.main_job_id].ens.."_"..res.jobs[player.sub_job_id].ens.."_"..player.name)
                    log(player.name..";load_"..res.jobs[player.main_job_id].ens.."_"..res.jobs[player.sub_job_id].ens.."_"..player.name)
                end
            end
            if settings.display == true and (enabled or following) then
                sm_display:show()
                sm_display:text(display_box_refresh())
            else
                sm_display:hide()
            end
            if settings.debug == true then
                sm_debug:text(debug_box_refresh())
            end
            last_update = now
        end
    end
end)

function log (msg)
    if settings.debug == true then
        if msg == nil then
            windower.add_to_chat(80,'---- Value is Nil ----')
        elseif type(msg) == "table" then
            for index, value in pairs(msg) do
                windower.add_to_chat(80,'---- '..tostring(value)..' ----')
            end
        elseif type(msg) == "number" then
            windower.add_to_chat(80,'---- '..tostring(msg)..' ----')
        elseif type(msg) == "string" then
            windower.add_to_chat(80,'---- '..msg..' ----')
        elseif type(msg) == "boolean" then
            windower.add_to_chat(80,'---- '..tostring(msg)..' ----')
        else
            windower.add_to_chat(80,'---- Unknown Debug Message ----')
        end
    end
end

function info (msg)
    if settings.info == true then
        if msg == nil then
            windower.add_to_chat(7,'---- Value is Nil ----')
        elseif type(msg) == "table" then
            for index, value in pairs(msg) do
                windower.add_to_chat(7,'---- '..tostring(value)..' ----')
            end
        elseif type(msg) == "number" then
            windower.add_to_chat(7,'---- '..tostring(msg)..' ----')
        elseif type(msg) == "string" then
            windower.add_to_chat(5,'---- '..msg..' ----')
        elseif type(msg) == "boolean" then
            windower.add_to_chat(7,'---- '..tostring(msg)..' ----')
        else
            windower.add_to_chat(7,'---- Unknown Debug Message ----')
        end
    end
end

function tablelength(T)
    local count = 0
    for _ in pairs(T) do count = count + 1 end
    return count
end

function randomseed()
    --Generate your seed
    seed = os.clock()*1000
    log("Your random Seed is ["..seed.."]")
    math.randomseed(seed)
end

function round(num, numDecimalPlaces)
  local mult = 10^(numDecimalPlaces or 0)
  return math.floor(num * mult + 0.5) / mult
end