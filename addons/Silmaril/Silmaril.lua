_addon.name = 'Silmaril'
_addon.author = 'Mirdain'
_addon.version = '2.4'
_addon_description = 'Allows for buffs, debuffs, ranged attacks, skill chains, magic bursts, and casting data'
_addon.commands = {'silmaril','sm'}

os.setlocale ("en")

packets = require 'packets'
config = require 'config'
res = require 'resources'
texts = require 'texts'

require 'tables'
require 'strings'
require 'coroutine'

-- These are Windower Raw values and refreshed via the "Update" function
player = {} -- get_player() 
pet = {}
time = nil -- computer time
party = {} -- get_party()
inventory = {} -- get_bag_info(0)
mob_array = {} -- grabs enemies via get_mob_array() under the tracking.lua
world = {} -- get_info()
ability_recasts = {} -- get_ability_recasts()
spell_recasts = {} -- get_spell_recasts()
spells_have = {} -- get_spells() via Update.lua

all_ability_recasts = res.ability_recasts -- Table with all abilities (loaded from windower resource files)
all_buffs = res.buffs -- Remaps so that geomancy buffs are fixed
all_job_abilities = res.job_abilities -- Store the resource information in a table
all_weapon_skills = res.weapon_skills -- Store the resource information in a table
all_spells = res.spells -- Store the resource information in a table
all_items = res.items -- Store the resource information in a table

--Update.lua
party_data = {} -- holds party information (generated by Party.lua)
party_buffs = {} -- holds buff list (generated by Player.lua and by Buffs.lua via packets)
player_status = {} -- hold character information (generated by Player.lua)
player_buffs = nil -- hold the player's buffs along with the duration
player_job_abilities_recasts = {} -- holds the characters recast timers of JA's (generated by Abilities.lua)
player_spell_recasts = {} -- holds the characters recast timers of spells (generated by Spells.lua)
player_world_data = {} -- holds the information on the world data
player_enemy_data = nil -- holds the information on the enemies data via World.lua
player_npc_data = nil -- holds the information on the enemies data via World.lua
player_task_data = {} -- holds the tasks to send to Silmaril
player_attack_target = nil -- holds the enemy that is currently being attacked
player_item_data = nil -- holds the inventory items to send to silmaril

--Others
player_zone_data = {} -- holds the information on the zone data
player_city_data = {} -- holds the information on the city data
player_location = {} -- stores the location of player via Moving_Check() in Moving.lua
player_abilities = {} -- used via "job_sync" in "Sync.lua"
party_location = {} -- stores the location of the party via Moving_Check() in Moving.lua

-- Global variables
enabled = false
connected = false
loaded = false
autoload = true
moving = false
following = false
delay_time = 0 -- Assign a random number to stagger the instances
zoning = false -- Used to determine if you are zoning or not
move_to_exit = false -- Used to run to exit line

-- Mirroring globals
player_mirror = false -- Player is set to mirror
mirroring = false
mirror_target = {} -- NPC the interaction for (used in Display)
release_packet = {} -- Holds the NPC menu information
mirror_message = {} -- Message to transmit
message_time = os.clock() - 5
injecting = false -- packets being sent
mirroring_state = "" -- this is used to notify the player of the actions
menu_id = 0

update_rate = .2 -- rate at which the updates are sent to Silmaril
last_update = os.clock()

update_movement = .1 -- rate at which movement checks are done (limit to 30 fps)
last_movement = os.clock()

update_inventory = 2 -- rate at which the game checks the players inventory
last_inventory = os.clock()

-- socket
socket = require("socket")
udp = nil
port = 2025
ip = "127.0.0.1"

require 'lib./Abilities' --Gets information about the player abilities
require 'lib./Buffs' --Used to process incoming buff packets for other party members
require 'lib./Burst' --Selects and returns the spell to burst
require 'lib./Commands' --Handles addon commands
require 'lib./Connection' --Send and Receive information
require 'lib./Display' --Send and Receive information
require 'lib./Input' --Receive commands to execute
require 'lib./Inventory' --Build the inventory information
require 'lib./Maps' --Allows for Geomancy and any future Buff updates by remapping to Silmaril
require 'lib./Mirror' -- Allows all members to mirror the main players actions
require 'lib./Moving' --Controls moving of charater
require 'lib./Packets' --Handles packet messages
require 'lib./Party' --Gets information about the current party and alliance
require 'lib./Player' --Gets information about the player
require 'lib./Skillchain' --Monitors action packets to build skillchains with
require 'lib./Spells' --Gets information about the player spells
require 'lib./Sync' --Gets information about ffxi and sends to the Silmaril
require 'lib./Tracking' --Used to handle targets and identify wanted enemies
require 'lib./Update' --Sets pace and updates globals form windower
require 'lib./World' --Gets information about the world

--Commands recieved and sent to addon
windower.register_event('addon command', function(input, ...)
    local args = L{...}
    log(args)
    commands(input,args)
end)

--Used to collect buffs of other instances on the same pc
windower.register_event('ipc message', function(msg)
    local args = msg:split(' ')
    local command = args:remove(1)
    if command == 'update' then
        local character = { id = tonumber(args[1]), name = args[2], zone = tonumber(args[3]), x = tonumber(args[4]), y = tonumber(args[5]), z = tonumber(args[6]), heading = tonumber(args[7]), status = tonumber(args[8]), target_index = tonumber(args[9])}
        party_location[tonumber(args[1])] = character
    elseif command == 'zone' then
        log('recieved IPC message of zone')
        zone_check(tonumber(args[1]),tonumber(args[2]),tonumber(args[3]),tonumber(args[4]),tonumber(args[5]),tonumber(args[6]),tonumber(args[7]))
    elseif command == 'message' then
    	local message = ""
		for index, item in ipairs(args) do
            if index ~= 0 then
                message = message..item..' '
            end
        end
        message = message:sub(1, #message - 1) -- remove last character
        command = 'input /echo '..message..''
        windower.send_command(command)
        log('Message recieved ['..message.."]")
    elseif command == 'mirror' then
        player_mirror = false
        mirroring = false
        injecting = false
        windower.add_to_chat(80,'------- Mirror [OFF]  -------')
    -- Leave at end to be a catch for commands
    elseif command and args[2] then
        log("IPC: ["..command.."] ["..args[2].."]")
        commands(command, args[2])
    elseif command then
        log("IPC: ["..command.."]")
        commands(command, "")
    end
end)

-- Used to track incoming information
windower.register_event('incoming chunk', function (id, original, modified, injected, blocked)
    message_in(id, original, modified, injected, blocked) -- process the packets via Packets.lua
    if injecting then
        if id == 0x032 then -- NPC Interaction Type 1
            log("Blocking on the 0x032 Packet")
            return true
        elseif id == 0x033 then -- String NPC Interaction
            log("Blocking on the 0x033 Packet")
            return true
        elseif id == 0x034 then -- NPC Interaction Type 2
            log("Blocking on the 0x034 Packet")
            return true
        end
    end
end)

-- Used to track outgoing information
windower.register_event('outgoing chunk', function (id, original, modified, injected, blocked)
    message_out(id, original, modified, injected, blocked) -- process the packets via Packets.lua
end)

windower.register_event('load', function()
    randomseed()
    delay_time = math.random(100,200)/100
    connect()
end)

windower.register_event('logout', function()
    send_packet(player.name..";reset")
    disconnect()
    log("logging out")
end)

windower.register_event('job change', function()
    coroutine.sleep(5)
    player_info()
    get_player_spells()
    autoload = true
end)

windower.register_event('zone change', function()
    player_info()
    world = windower.ffxi.get_info()
    if player then
        commands("stop", "")
    end
end)

windower.register_event('unload', function()
    send_packet(player.name..";reset")
    disconnect()
    log("unloaded")
end)

windower.register_event('prerender', function()
    if loaded then
        receive_info()
        local now = os.clock() -- used to determine the elapsed time
        if now - last_movement > update_movement then
            IPC_update() -- Update the player data via Moving.lua.  This allows accurate info
            last_movement = now
        end
        if now - last_inventory > update_inventory then
            get_inventory()
            last_inventory = now
        end
        if now - last_update > update_rate then
            if injecting and os.clock() - message_time > 10 then
                debug("Time out of mirror reached - Trying to reset.")
                npc_reset()
            end
            if not connected then
                request()
                following = false
                enabled = false
            else
                update() -- Via Update.lua
                if autoload then
                    autoload = false;
                    send_packet(player.name..";load_"..res.jobs[player.main_job_id].ens.."_"..res.jobs[player.sub_job_id].ens.."_"..player.name)
                    log(player.name..";load_"..res.jobs[player.main_job_id].ens.."_"..res.jobs[player.sub_job_id].ens.."_"..player.name)
                end
            end
            if settings.display and (enabled or following or player_mirror) then
                sm_display:show()
                sm_display:text(display_box_refresh())
            else
                sm_display:hide()
            end
            if settings.debug then
                sm_debug:text(debug_box_refresh())
            end
            if mirroring or injecting then
                sm_npc:text(npc_box_refresh())
                sm_npc:show()
            else
                sm_npc:hide()
            end
            last_update = now
        end
    end
end)

function log (msg)
    if settings.debug == true then
        if msg == nil then
            windower.add_to_chat(80,'---- Value is Nil ----')
        elseif type(msg) == "table" then
            for index, value in pairs(msg) do
                windower.add_to_chat(80,'---- '..tostring(value)..' ----')
            end
        elseif type(msg) == "number" then
            windower.add_to_chat(80,'---- '..tostring(msg)..' ----')
        elseif type(msg) == "string" then
            windower.add_to_chat(80,'---- '..msg..' ----')
        elseif type(msg) == "boolean" then
            windower.add_to_chat(80,'---- '..tostring(msg)..' ----')
        else
            windower.add_to_chat(80,'---- Unknown Debug Message ----')
        end
    end
end

function info (msg)
    if settings.info == true then
        if msg == nil then
            windower.add_to_chat(7,'---- Value is Nil ----')
        elseif type(msg) == "table" then
            for index, value in pairs(msg) do
                windower.add_to_chat(7,'---- '..tostring(value)..' ----')
            end
        elseif type(msg) == "number" then
            windower.add_to_chat(7,'---- '..tostring(msg)..' ----')
        elseif type(msg) == "string" then
            windower.add_to_chat(5,'---- '..msg..' ----')
        elseif type(msg) == "boolean" then
            windower.add_to_chat(7,'---- '..tostring(msg)..' ----')
        else
            windower.add_to_chat(7,'---- Unknown Debug Message ----')
        end
    end
end

function tablelength(T)
    local count = 0
    for _ in pairs(T) do count = count + 1 end
    return count
end

function randomseed()
    --Generate your seed
    seed = os.clock()*1000
    log("Your random Seed is ["..seed.."]")
    math.randomseed(seed)
end

function round(num, numDecimalPlaces)
  local mult = 10^(numDecimalPlaces or 0)
  return math.floor(num * mult + 0.5) / mult
end

do
    local now = os.time()
    local h, m = (os.difftime(now, os.time(os.date('!*t', now))) / 3600):modf()
    local timezone = '%+.2d:%.2d':format(h, 60 * m)
    local fn = function(ts)
        return os.date('%Y-%m-%dT%H:%M:%S' .. timezone, ts)
    end
    time = function(ts)
        return fn(os.time() - ts)
    end
    bufftime = function(ts)
        return fn(1009810800 + (ts / 60) + 0x100000000 / 60 * 9) -- increment last number every 2.27 years
    end
end